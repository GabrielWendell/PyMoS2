"""
This is the Stellar Structure module of the MoS2 package whose objective 
is to simulate energy transport by radiation and convection in the stellar interior.

Rocha, G. W. C. (2021)
"""

import matplotlib.pyplot as plt
from scipy import interpolate
import numpy as np
# import smplotlib



# ---------------------------------------------------------------------------------------------------------------------
def opt_plot():
    """
    This function helps to improve the aesthetics of a single graphic!
    """
    # plt.style.use('dark_background')
    plt.grid(True, linestyle = ':', color = '0.50')
    plt.minorticks_on()
    plt.tick_params(axis = 'both', which = 'minor', direction = "in",
                    top = True, right = True, length = 5, width = 1,labelsize = 15)
    plt.tick_params(axis='both', which='major', direction = "in",
                    top = True, right = True, length = 8, width = 1, labelsize = 15)

def opt_plot_mod(ax):
    """
    This function helps to improve the aesthetics of a graph tied to a certain axis!
    """
    # plt.style.use('dark_background')
    ax.grid(True, linestyle = ':', color = '0.50')
    ax.minorticks_on()
    ax.tick_params(axis = 'both', which = 'minor', direction = "in",
                        top = True,right = True, length = 5,width = 1, labelsize = 15)
    ax.tick_params(axis = 'both', which = 'major', direction = "in",
                        top = True, right = True, length = 8,width = 1, labelsize = 15) 
    
def style():
    """
    This function applies this style to all graphics generated by the code.
    """
    from matplotlib import rcParams
    import matplotlib.font_manager as font_manager
    
    # Uncomment the lines below to use custom fonts by specifying the path to them.
    
    # font_dirs = 'C:/Python36/Lib/site-packages/matplotlib/mpl-data/fonts/ttf'
    # font_files = font_manager.findSystemFonts(fontpaths = font_dirs)
    # font_list = font_manager.createFontList(font_files)
    # font_manager.fontManager.ttflist.extend(font_list)
    rcParams['font.family'] = 'monospace'
    rcParams['font.size'] = 18
    rcParams['mathtext.fontset'] = 'dejavuserif'
    rcParams['axes.linewidth'] = 1.2

style()
    
    


# ---------------------------------------------------------------------------------------------------------------------



# Functions needed in the computations

def read_kappa(T, rho): 
   '''
   This function reads the table that contais the opacities values,
    interpolating or extrapolatinf the values if necessary.

    Args:
        T (_float_): Temperature value;
        rho (_float_): Density value.

    Returns:
        kappa_value (_array_): Rate of energy production in each layer of the star.
   ''' 

   rho_cgs = 1e-3*rho
   R = 1e18*rho_cgs*T**(-3.)
   infile = open('Opacities.txt', 'r')
   rows = infile.readlines()
   infile.close()
   log_R = rows[0].split()
   log_R = log_R[1:]
   log_R = [float(logR) for logR in log_R]
   
   log_T = []
   log_kappa = []
   for r in rows[2:]: 
      # Skil log_R row and a blank row 
      r_list = r.split()
      r_list = [float(rs) for rs in r_list]
      temperature = r_list[0]
      kappas = r_list[1:]
      log_T.append(temperature)
      log_kappa.append(kappas)
   
   # All quantities below are in cgs system units  
   log_T = np.array(log_T)              
   log_R = np.array(log_R) 
   log_kappa = np.array(log_kappa) 
   
   T_log = np.log10(T)
   R_log = np.log10(R)
   
   # When the input value can be found in the table:
   for i in range(len(log_T)):  
      if T_log == log_T[i]:
         kappa_1index = i
         # print("log(T) found in the table")
         break
      else:
         kappa_1index = 'Not Found'
   for i in range(len(log_R)):  
      if R_log == log_R[i]:
         kappa_2index = i
         # print("log(R) found in the table")
         break
      else:
         kappa_2index = 'Not Found'
   
   # Extrapolation warning
   if T_log < 3.75 or T_log > 8.7:
      print('Extrapolation: log(T) outside the bounds of the table')
   if R_log < -8.0 or R_log > 1.:
      print('Extrapolation: log(R) outside the bounds of the table')
   
   
   if kappa_1index != 'Not Found' and kappa_2index != 'Not Found':
      log_kappa_value = log_kappa[kappa_1index][kappa_2index]
      # Units in the cgs system
      kappa_value = 10**log_kappa_value 
   else: 
      log_kappa_value_function = interpolate.interp2d(log_R, log_T, log_kappa, kind = 'linear', copy = False, bounds_error = False, fill_value = None)
      log_kappa_value = log_kappa_value_function(R_log, T_log)
      # Unit in the cgs systems
      kappa_value = 10**log_kappa_value[0] 
      
   # Convert to S.I. units   
   return kappa_value/10. 

     
  
def energy_PP(T, rho): 
   '''
   This function returns the energy generation rate through 
   PP chain reactions.

    Args:
        T (_float_): Temperature value;
        rho (_float_): Density value.

    Returns:
        _array_: Rate of energy generation in each reaction.
   '''  
   MeV = 1.60218*10**(-13.) # [MeV] = J
   
   # All reactions below have Joule unit
   Q_pp = (0.15 + 1.02)*MeV # [J]
   Q_Dp = 5.49*MeV   # [J]
   Q_33 = 12.86*MeV  # [J]
   Q_34 = 1.59*MeV   # [J]
   Q_7e = 0.05*MeV   # [J]
   Q_71_ = 17.35*MeV # [J]
   Q_71 = (0.14 + 1.02 + 6.88 + 3.0)*MeV  #[J]
   
   # Here we convert the temperature to units of 10^(9) Kelvin.
   T_9 = T*10**(-9.) 
   T_9_ = T_9/(1+4.95*10**(-2.)*T_9)
   T_9__ = T_9/(1+0.759*T_9)
   
   N_A_Lamb_pp = 4.01*10**(-15.)*T_9**(-2./3.)*np.exp(-3.38*T_9**(-1./3.))*(1. + 0.123*T_9**(1./3.) + 1.09*T_9**(2./3.) + 0.938*T_9)
   N_A_Lamb_33 = 6.04e10*T_9**(-2./3.)*np.exp(-12.276*T_9**(-1./3.))*(1+0.034*T_9**(1./3.) - 0.522*T_9**(2./3.) - 0.124*T_9 + 0.353*T_9**(4./3.) + 0.213*T_9**(-5./3.))
   N_A_Lamb_34 = 5.61e6*T_9_**(5./6.)*T_9**(-3./2.)*np.exp(-12.826*T_9_**(-1./3.))
   N_A_Lamb_7e = 1.34*10**(-10.)*T_9**(-1./2.)*(1. - 0.537*T_9**(1./3.) + 3.86*T_9**(2./3.) + 0.0027*T_9**(-1.)*np.exp(2.515*10**(-3.)*T_9**(-1.)))
   N_A_Lamb_71_ = 1.096e9*T_9**(-2./3.)*np.exp(-8.472*T_9**(-1./3.)) - 4.83e8*T_9__**(5./6.)*T_9**(-3./2.)*np.exp(-8.472*T_9__**(-1./3.)) + 1.06e10*T_9**(-3./2.)*np.exp(-30.442*T_9**(-1.))
   N_A_Lamb_71 = 3.11e5*T_9**(-2./3.)*np.exp(-10.262*T_9**(-1./3.)) + 2.53e3*T_9**(-3./2.)*np.exp(-7.306*T_9**(-1.))
   
   n_p = rho*X/(1.*m_u)
   n_He = rho*Y/(4.*m_u) 
   # We need to include both He_3 and He_4 in the chain reaction.
   n_He_3 = rho*Y_3/(3.*m_u)
   n_He_4 = n_He - n_He_3
   n_Be = rho*Z_Be/(7.*m_u)
   n_Li = rho*Z_Li/(7.*m_u)
   n_e = n_p + 2.*n_He_3 + 2.*n_He_4 + 2.*n_Be + 1.*n_Li

   Lamb_pp = 1e-6*N_A_Lamb_pp/N_A       # [Lamb_pp] = m^3/s
   Lamb_33 = 1e-6*N_A_Lamb_33/N_A       # [Lamb_33] = m^3/s
   Lamb_34= 1e-6*N_A_Lamb_34/N_A        # [Lamb_34] = m^3/s
   if T < 1e6:
      if N_A_Lamb_7e > 1.57e-7/n_e:
         N_A_Lamb_7e = 1.57e-7/n_e
   Lamb_7e = 1e-6*N_A_Lamb_7e/N_A       # Be + e: # [Lamb_7e] = m^3/s
   Lamb_71_ = 1e-6*N_A_Lamb_71_/N_A     # Li + H: # [Lamb_71_] = m^3/s
   Lamb_71 = 1e-6*N_A_Lamb_71/N_A       # Be + H: # [Lamb_71] = m^3/s

   r_pp = n_p*n_p*Lamb_pp/(rho*2.)
   r_33 = n_He_3*n_He_3*Lamb_33/(rho*2.)
   r_34 = n_He_3*n_He_4*Lamb_34/rho
   if r_pp < (r_33*2. + r_34):
      rate1 = r_pp/(2.*r_33 + r_34)
      r_33 *= rate1
      r_34 *= rate1
      
   r_7e = n_Be*n_e*Lamb_7e/rho
   r_71_ = n_Li*n_p*Lamb_71_/rho
   r_71 = n_Be*n_p*Lamb_71/rho
   if r_34 < (r_7e + r_71):
      rate2 = r_34/(r_7e + r_71)
      r_7e *= rate2
      r_71 *= rate2
   if r_7e < r_71_:
      rate3 = r_7e/r_71_
      r_71_ *= rate3
 
   # - eps: Total energy production 
   # - eps1: PP1 branch
   # - eps2: PP2 branch
   # - eps3: PP3 branch
   eps = r_pp*(Q_pp + Q_Dp) + r_33*Q_33 + r_34*Q_34 + r_7e*Q_7e + r_71_*Q_71_ + r_71*Q_71 
   eps1 = (2.*(Q_pp + Q_Dp) + Q_33)*r_33 
   eps2 = (eps1 + Q_pp + Q_Dp + Q_34)*r_34 + (eps1 + Q_pp + Q_Dp + Q_34 + Q_7e)*r_7e + (eps1 + Q_pp + Q_Dp + Q_34 + Q_7e + Q_71_)*r_71_
   eps3 = (eps1 + Q_pp + Q_Dp + Q_34)*r_34 + (eps1 + Q_pp + Q_Dp + Q_34 + Q_71)*r_71 
   
   return [eps, eps1/(eps1 + eps2 + eps3), eps2/(eps1 + eps2 + eps3), eps3/(eps1 + eps2 + eps3)]



def calculate_P(rho, T): 
   '''
   This function returns the pressure in a given layer of the star.

    Args:
        rho (_float_): Current layer density value;
        T (_float_): Current layer temperature value.

    Returns:
        P (_float_): Current layer pressure value.
   '''  
   P_rad = (a*T**4.)/3.   
   P_G = rho*k_B*T/(mu*m_u)
   P = P_rad + P_G
   
   return P



def calculate_rho(P, T):
   '''
   This function returns the density in a given layer of the star.

    Args:
        P (_float_): Current layer pressure value;
        T (_float_): Current layer temperature value.

    Returns:
        rho (_float_): Current layer density value.
   '''  
   P_rad = (a*T**4.)/3.   
   P_G = P - P_rad
   rho = P_G*mu*m_u/(k_B*T)
   
   return rho



def Hp(_R_, _T_, _M_): 
   '''
   This function returns the pressure scale height
   in a given layer of the star.

    Args:
        _R_ (_float_): Current layer radius value;
        _T_ (_float_): Current layer temperature value;
        _M_ (_float_): Current layer mass value.

    Returns:
        Hp (_float_): Current layer pressure scale height value.
   '''  
   Hp = (k_B*_T_*_R_**2.)/(mu*m_u*G*_M_)
   
   return Hp



def U(_T_, kappa, _rho_, _Hp_, _R_, _M_): 
   '''
   This function calculates the internal energy U. 
   It will be needed later when calculating the temperature gradient.

    Args:
        _T_ (_float_): Current layer temperature value;
        kappa (_float_): Rate of energy generation;
        _rho_ (_float_): Current layer density value
        _Hp_ (_float_): Current layer pressure scale height value;
        _R_ (_float): Current layer radius value;
        _M_ (_float_): Current layer mass value.
        

    Returns:
        U (_float_): Current layer internal energy value.
   '''  
   U = ((64.*sigma*_T_**3.)/(3.*kappa*(_rho_/(m_u*mu*N_A))*_rho_*c_p))*((_Hp_*_R_**2.)/(G*_M_*delta))**(1./2.)
   
   return U



def calculate_xi(Hp_, U_,Nabla_ad_,Nabla_stable_): #calculating xi, needed for temperature gradient
   
   
   # Find all roots of the polynomial equation
   xi_ = np.roots([(alpha*Hp_)**2/U_, 1., 4.*U_/(alpha*Hp_)**2, Nabla_ad_ - Nabla_stable_]) 
   for i in range(len(xi_)):
      if xi_[i].imag < 1e-5:
             # Choose the real solution
         xi_s = xi_[i].real 
         
   return xi_s



# ---------------------------------------------------------------------------------------------------------------



'''
Constants and parameters used
'''

# Fractional bbundances by weight
X = 0.7                    # H
Y_3 = 1e-10                # He_3
Y = 0.29                   # He_3 + He_4
Z = 0.01                   # Metals
Z_Li = 1e-13               # Li
Z_Be = 1e-13               # Be
mu = 1./(2.*X + 3.*Y/4. + Z/2.)

sigma = 5.67e-8            # [sigma] = W * m^-2 * K^-4
c = 2.998e8                # [c] = m/s
k_B = 1.382e-23            # [k_B] = m^2 * kg * s^-2 * K^-1
m_u = 1.6605*10**(-27.)    # [m_u] = kg  
a = (4.*sigma)/c           # [a] = W * m^-1 * s^-1 * K^-4
G = 6.672e-11              # [G] = N * m^2 * kg^-2
N_A = 6.022*10**23         # [N_A] = 1/mol
R_const = 8.314            # [R_const] = J * mol^-1 * K^-1

alpha = 1.
delta = 1.
c_p = 5.*R_const/2.

R_Sun = 6.96e8             # [R_Sun] = m (radius of the Sun)
rho_Sun = 1.408e3          # [rho_Sun] = kg * m^-3 (average density of the Sun)
M_Sun = 1.989e30           # [M_Sun] = kg (mass of the entire Sun)
L_Sun = 3.846e26           # [L_Sun] = W (luminosity of the Sun)



# ---------------------------------------------------------------------------------------------------------------



'''
FIRST SANITY CHECK
'''
T_sanity = 0.9*10**6       # [T_sanity] = K
rho_sanity = 55.9          # [rho_sanity] = kg * m^-3
R_sanity = 0.84*R_Sun      # [R_sanity] = m
M_sanity = 0.99*M_Sun      # [M_sanity] = kg
kappa_sanity = 3.98        # [kappa_sanity] = m^2 * kg^-1

Hp_sanity = Hp(R_sanity, T_sanity, M_sanity)
Nabla_stable_sanity = (3.*kappa_sanity*rho_sanity*Hp_sanity*L_Sun)/(64.*np.pi*R_sanity**2.*sigma*T_sanity**4.)
Nabla_ad_sanity = (2.*alpha)/(5.*delta)
U_sanity = U(T_sanity, kappa_sanity, rho_sanity, Hp_sanity, R_sanity, M_sanity)
xi_s = calculate_xi(Hp_sanity, U_sanity, Nabla_ad_sanity, Nabla_stable_sanity)
Nabla_star_sanity = xi_s**2. + (4*U_sanity/(alpha*Hp_sanity)**2)*xi_s + Nabla_ad_sanity
v_sanity = ((G*M_sanity*Hp_sanity)**(1./2.)/(2.*R_sanity))*xi_s
F_rad_sanity = 16.*sigma*T_sanity**4.*Nabla_star_sanity/(3.*kappa_sanity*rho_sanity*Hp_sanity)
F_C_sanity = 16.*sigma*T_sanity**4.*Nabla_stable_sanity/(3.*kappa_sanity*rho_sanity*Hp_sanity) - F_rad_sanity
frac1_sanity = F_C_sanity/(F_C_sanity + F_rad_sanity)
frac2_sanity = F_rad_sanity/(F_C_sanity + F_rad_sanity)
Nabla_p_sanity = Nabla_star_sanity - xi_s**2.



'''
STARTING POINT
'''
# Initial values used in the second sanity check, with plots:
rho_0 = 1.42e-7*rho_Sun    # [rho_0] = kg * m^-3
T_0 = 5770.                # [T_0] = K
R_0 = R_Sun                # [R_0] = m
# p = 0.01                 # Allowed fraction of change

# Best-fit:
# Comment this part to perform sanity check
rho_0 = 217*rho_0
T_0 = 1.4*T_0
R_0 = 0.85*R_0
M_0 = M_Sun
L_0 = L_Sun
p = 0.075 
# -----------------------------------------------------------------


# Max number of datapoints
# if the mass is negative or step length gets too small:
# - it cuts the loop and plotting before that!
n = 1e4
n = int(n)
# Plot of the whole array if the mass doesn't get negative
breaking_point = n 

# Arrays that will be updated in the loop
mass = np.zeros(n)
radius = np.zeros(n)
pressure = np.zeros(n)
luminosity = np.zeros(n)
temperature = np.zeros(n)
density = np.zeros(n)
epsilon = np.zeros(n)         # Total energy production
epsilon1 = np.zeros(n)        # PP1 branch
epsilon2 = np.zeros(n)        # PP2 branch
epsilon3 = np.zeros(n)        # PP3 branch
Nabla_ad = np.zeros(n)        # Adiabatic temperature gradient
Nabla_star = np.zeros(n)
Nabla_stable = np.zeros(n)
F_C_ = np.zeros(n)            # Fraction of the energy transported by convection
F_rad_ = np.zeros(n)          # Fraction of the energy transported by radiation


'''
INITIAL VALUES
'''
mass[0] = M_0
radius[0] = R_0
pressure[0] = calculate_P(rho_0,T_0) 
luminosity[0] = L_0
temperature[0] = T_0
density[0] = rho_0
epsilon[0] = energy_PP(T_0, rho_0)[0] 
epsilon1[0] = energy_PP(T_0, rho_0)[1] 
epsilon2[0] = energy_PP(T_0, rho_0)[2] 
epsilon3[0] = energy_PP(T_0, rho_0)[3] 
Nabla_ad[0] = (2.*alpha)/(5.*delta)

Nabla_stable[0] = (3.*read_kappa(T_0, rho_0)*rho_0*Hp(R_0,T_0,M_0)*L_0)/(64.*np.pi*R_0**2.*sigma*T_0**4.)
Hp_0 = Hp(R_0,T_0,M_0)
U_0 = U(T_0, read_kappa(T_0,rho_0),rho_0,Hp_0,R_0,M_0)
xi_0 = calculate_xi(Hp_0, U_0,Nabla_ad[0], Nabla_stable[0])
Nabla_star[0] = xi_0**2. + (4*U_0/(alpha*Hp_0)**2)*xi_0 + Nabla_ad[0]
F_rad0 = (16.*sigma*T_0**4.*Nabla_star[0]/(3.*read_kappa(T_0, rho_0)*rho_0*Hp_0))
F_C0 = (16.*sigma*T_0**4.*Nabla_stable[0]/(3.*read_kappa(T_0, rho_0)*rho_0*Hp_0)) - F_rad0
F_C_[0] = F_C0/(F_C0 + F_rad0)
F_rad_[0] = F_rad0/(F_C0 + F_rad0)


# Update arrays:
# - integrate toward the center of the star with mass as an independent variable
for i_ in range(1, n):
      f1 = 1./(4.*np.pi*(radius[i_-1]**2)*density[i_-1])
      dm1 = p*radius[i_-1]/f1
      f2 = -G*mass[i_-1]/(4.*np.pi*(radius[i_-1]**4))
      dm2 = p*pressure[i_-1]/f2
      f3 = epsilon[i_-1]
      dm3 = p*luminosity[i_-1]/f3
      kappa = read_kappa(temperature[i_-1], density[i_-1])
      Hp_before = Hp(radius[i_-1], temperature[i_-1], mass[i_-1])
      # Convective instability --> Convection
      if Nabla_stable[i_-1] > Nabla_ad[i_-1]: 
         f4 = -(temperature[i_-1]*Nabla_star[i_-1]*f1)/Hp_before
      # Convective stability --> No convection
      else: 
         f4 = -(temperature[i_-1]*Nabla_stable[i_-1]*f1)/Hp_before
      dm4 = p*temperature[i_-1]/f4
      # Choose the smallest mass-step
      dm = -1.*(min(abs(dm1), abs(dm2), abs(dm3), abs(dm4))) 
      mass[i_] = mass[i_-1] + dm
      radius[i_] = radius[i_-1] + dm*f1
      pressure[i_] = pressure[i_-1] + dm*f2
      luminosity[i_] = luminosity[i_-1] + f3*dm
      temperature[i_] = temperature[i_-1] + f4*dm
      density[i_] = calculate_rho(pressure[i_], temperature[i_])
      epsilon[i_] = energy_PP(temperature[i_],density[i_])[0]
      epsilon1[i_] = energy_PP(temperature[i_],density[i_])[1]
      epsilon2[i_] = energy_PP(temperature[i_],density[i_])[2]
      epsilon3[i_] = energy_PP(temperature[i_],density[i_])[3]
      # Cut the loop if the mass turns negative
      if mass[i_] < 0.: 
         breaking_point = i_ 
         break
      Hp_new = Hp(radius[i_], temperature[i_], mass[i_])
      kappa_new = read_kappa(temperature[i_], density[i_])
      Nabla_stable[i_] = (3.*kappa_new*density[i_]*Hp_new*luminosity[i_])/(64.*np.pi*radius[i_]**2.*sigma*temperature[i_]**4.)
      Nabla_ad[i_] = Nabla_ad[i_-1]
      U_new = U(temperature[i_], kappa_new, density[i_], Hp_new, radius[i_], mass[i_])
      xi_new = calculate_xi(Hp_new, U_new,Nabla_ad[i_], Nabla_stable[i_])
      # Convection
      if Nabla_stable[i_] > Nabla_ad[i_]: 
         Nabla_star[i_] = xi_new**2. + (4*U_new/(alpha*Hp_new)**2)*xi_new + Nabla_ad[i_]
      # No convection
      else: 
         Nabla_star[i_] = Nabla_stable[i_]
      F_rad = 16.*sigma*temperature[i_]**4.*Nabla_star[i_]/(3.*kappa_new*density[i_]*Hp_new)
      F_C = 16.*sigma*temperature[i_]**4.*Nabla_stable[i_]/(3.*kappa_new*density[i_]*Hp_new) - F_rad
      F_C_[i_] = F_C/(F_C + F_rad)
      F_rad_[i_] = F_rad/(F_C + F_rad)

 
# Check the radius of the core
for l in range(len(luminosity)):
   if luminosity[l]/L_Sun < 0.995:
      core_starts = l
      break

# Check the width of layers
outer_convection_layer = []
outer_radiation_layer = []
inner_radiation_layer = []
inner_convection_layer = []
for k_ in range(len(F_C_[:breaking_point])):
   # Outside the core
   if luminosity[k_]/L_Sun > 0.995: 
      # Convection
      if F_C_[k_] > 0.0: 
         outer_convection_layer.append(radius[k_]/R_0)
      # Radiation   
      else:
         outer_radiation_layer.append(radius[k_]/R_0)
   # Inside the core      
   else: 
      # Convection
      if F_C_[k_] > 0.0: 
         inner_convection_layer.append(radius[k_]/R_0)
      # Radiation   
      else: 
         inner_radiation_layer.append(radius[k_]/R_0)
outer_convection_layer = np.array(outer_convection_layer)
inner_convection_layer = np.array(inner_convection_layer)
outer_radiation_layer = np.array(outer_radiation_layer)
inner_radiation_layer = np.array(inner_radiation_layer)


# Logarithmic scale for pressure and density
l_pressure = np.log10(pressure[:breaking_point])
l_density = np.log10(density[:breaking_point])



# ---------------------------------------------------------------------------------------------------------------

'''
PRINTOUS & PLOTS
'''

# Printouts
print('First sanity check (in order of example 5.1):')
print(Nabla_stable_sanity, Nabla_ad_sanity, Hp_sanity*1e-6,'Mm', U_sanity, xi_s, Nabla_star_sanity, v_sanity, 'm/s', frac1_sanity, frac2_sanity)
print(Nabla_ad_sanity, '<', Nabla_p_sanity, '<', Nabla_star_sanity, '<', Nabla_stable_sanity)

print('Number of datapoints used:',  breaking_point)
print('Final radius:', (radius[breaking_point-1]/radius[0])*100, '% of initial radius.')
print('Final mass:', (mass[breaking_point-1]/mass[0])*100, '% of initial mass.')
print('Final luminosity:',(luminosity[breaking_point-1]/luminosity[0])*100, '% of initial luminosity.')
print('Radius of the core:', (radius[l]/radius[0])*100, '% of initial radius.')

print('Width of the outer convection layer:', (outer_convection_layer[0] - outer_convection_layer[-1])*100, '% of initial radius.')
print('Width of the outer radiation layer:', (outer_radiation_layer[0] - outer_radiation_layer[-1])*100, '% of initial radius.')
print('Width of the inner radiation layer:', (inner_radiation_layer[0] - inner_radiation_layer[-1])*100, '% of initial radius.')
print('Width of the inner convection layer:', (inner_convection_layer[0] - inner_convection_layer[-1])*100, '% of initial radius.')


# ---------------------------------------------------------------------------------------------------------------


# CROSS-SECTION
R_values = radius[:breaking_point]/R_Sun
L_values = luminosity[:breaking_point]/L_Sun 
R0 = radius[0]/R_Sun
show_every = 5
core_limit = 0.995

plt.figure(figsize = (8,5))
# Get current figure
plt.fig = plt.gcf() 
# Get current axis
ax = plt.gca()  
rmax = 1.2*R0
ax.set_xlim(-rmax,rmax)
ax.set_ylim(-rmax,rmax)
# Make the plot circular
ax.set_aspect('equal')	
j = show_every
for k in range(0, breaking_point-1):
	j += 1
   # Don't show every step
	if j >= show_every:	
      # Outside core
		if(L_values[k] > core_limit):
         # Convection
			if(F_C_[k] > 0.0):		
				circR = plt.Circle((0,0), R_values[k], color = 'firebrick', fill = False)
				ax.add_artist(circR)
         # Radiation
			else:				
				circY = plt.Circle((0,0), R_values[k], color = 'yellow', fill = False)
				ax.add_artist(circY)
      # Inside core
		else:				
         # Convection
			if(F_C_[k] > 0.0):		
				circB = plt.Circle((0,0), R_values[k], color=  'navy', fill = False)
				ax.add_artist(circB)
         # Radiation
			else:				
				circC = plt.Circle((0,0), R_values[k], color = 'c', fill = False)
				ax.add_artist(circC)
		j = 0
# These are for the legend (drawn outside the main plot)
circR = plt.Circle((2*rmax,2*rmax), 0.1*rmax, color = 'firebrick', fill = True)	
circY = plt.Circle((2*rmax,2*rmax), 0.1*rmax, color = 'yellow', fill = True)
circC = plt.Circle((2*rmax,2*rmax), 0.1*rmax, color = 'c', fill = True)
circB = plt.Circle((2*rmax,2*rmax), 0.1*rmax, color = 'navy', fill = True)
# Only add one (the last) circle of each colour to legend
plt.legend([circR, circY, circC, circB], ['Convection outside core', 'Radiation outside core', 'Radiation inside core', 'Convection inside core']) 
# plt.legend(loc = 2)
plt.xlabel('$R/R_{\odot}$')
plt.ylabel('$R/R_{\odot}$')
plt.title('Cross-section of star', fontsize = 22)
opt_plot()
plt.savefig('Cross_section.png', dpi = 400)
plt.show()


plt.figure(figsize = (8,5))
plt.plot(radius[:breaking_point]/R_Sun, Nabla_stable[:breaking_point], color = 'navy' )
plt.plot(radius[:breaking_point]/R_Sun, Nabla_star[:breaking_point], color = 'firebrick')
plt.plot(radius[:breaking_point]/R_Sun, Nabla_ad[:breaking_point], color = 'darkcyan')
plt.xlabel('$R/R_{\odot}$')
plt.ylabel('$\\nabla$')
plt.legend(['$\\nabla_{stable}$', '$\\nabla^{\star}}$','$\\nabla_{ad}$'], fontsize = 16, loc = 'upper center')
plt.title('Temperature gradients')
ax = plt.gca()
ax.set_yscale('log')
plt.axis([radius[breaking_point - 1]/R_Sun - 0.01, radius[0]/R_Sun + 0.01, 0, max(Nabla_stable)])
opt_plot()
plt.savefig('Temperature_Gradients.png', dpi = 400)
plt.show()


plt.figure(figsize = (8,5))
plt.scatter(outer_convection_layer*R_0/R_Sun, Nabla_star[:len(outer_convection_layer)], color = 'firebrick', s = 5)
plt.plot(outer_convection_layer*R_0/R_Sun, Nabla_ad[:len(outer_convection_layer)],color = 'darkcyan')
opt_plot()
plt.xlabel('$R/R_{\odot}$')
plt.ylabel('$\\nabla$')
plt.legend(['$\\nabla_{stable}$', '$\\nabla^{\star}}$','$\\nabla_{ad}$'], fontsize = 16, loc = 'upper center')
plt.title('Outer convection layer')
plt.axis([outer_convection_layer[-1]*R_0/R_Sun, outer_convection_layer[0]*R_0/R_Sun + 0.005, 0.395, 0.425])
plt.savefig('Outer_Conv_Layer.png', dpi = 400)
plt.show()


plt.figure(figsize = (8,5))
plt.plot(radius[:breaking_point]/R_Sun, epsilon1[:breaking_point], color = 'navy' )
plt.plot(radius[:breaking_point]/R_Sun, epsilon2[:breaking_point], color = 'firebrick')
plt.plot(radius[:breaking_point]/R_Sun, epsilon3[:breaking_point], color = 'darkcyan')
plt.plot(radius[:breaking_point]/R_Sun, epsilon[:breaking_point]/max(epsilon), color = 'darkorange')
plt.xlabel('$R/R_{\odot}$')
plt.ylabel('$\\varepsilon$')
plt.axis([radius[breaking_point - 1]/R_Sun, radius[0]/R_Sun, 0, 1])
plt.legend(['$\\varepsilon_{PPI}$', '$\\varepsilon_{PPII}}$','$\\varepsilon_{PPIII}$', '$ \\varepsilon / \\varepsilon_{max} $'], fontsize = 16)
plt.title('Energy production rate')
opt_plot()
plt.savefig('Energy_Prod_rate.png', dpi = 400)
plt.show()


plt.plot(radius[:breaking_point]/R_Sun, luminosity[:breaking_point]/L_Sun, color = 'darkorange')
plt.title('Luminosity vs. Radius', fontsize = 20)
plt.xlabel('$R/R_{\odot}$')
plt.ylabel('$L/L_{\odot}$')
plt.axis([radius[breaking_point-1]/R_Sun, radius[0]/R_Sun, 0, 1.05])
plt.axvline(x = radius[core_starts]/R_Sun, linestyle = 'dashed', color = 'red')
opt_plot()
plt.savefig('Luminosity_Radius.png', dpi = 400)
plt.show()


plt.plot(radius[:breaking_point]/R_Sun, l_density, color = 'slateblue')
plt.title('Density vs. Radius', fontsize = 20)
plt.xlabel('$R/R_{\odot}$')
plt.ylabel('$\log{(\\rho)}$ [kg$\cdot$m$^{-3}$]')
plt.axis([radius[breaking_point-1]/R_Sun, radius[0]/R_Sun, l_density[0],l_density[breaking_point - 1]])
opt_plot()
plt.savefig('Density_Radius.png', dpi = 400)
plt.show()


plt.plot(radius[:breaking_point]/R_Sun, temperature[:breaking_point]/1e6, color = 'darkred')
plt.title('Temperature vs. Radius', fontsize = 20)
plt.axis([radius[breaking_point-1]/R_Sun, radius[0]/R_Sun, T_0/1e6, temperature[breaking_point - 1]/1e6])
plt.xlabel('$R/R_{\odot}$')
plt.ylabel('$T$ [MK]', fontsize = 16)
opt_plot()
plt.savefig('Temperature_Radius.png', dpi = 400)
plt.show()


plt.plot(radius[:breaking_point]/R_Sun, l_pressure, color = 'darkblue')
plt.title('Pressure vs. Radius', fontsize = 20)
plt.axis([radius[breaking_point - 1]/R_Sun, radius[0]/R_Sun, l_pressure[0], l_pressure[breaking_point - 1]])
plt.xlabel('$R/R_{\odot}$')
plt.ylabel('$\log{(P)}$ [Pa]')
opt_plot()
plt.savefig('Pressure_Radius.png', dpi = 400)
plt.show()


plt.plot(radius[:breaking_point]/R_Sun, mass[:breaking_point]/M_Sun, color = 'darkgreen')
plt.title('Mass vs. Radius', fontsize = 20)
plt.axis([radius[breaking_point-1]/R_Sun, radius[0]/R_Sun, 0, 1.05])
plt.xlabel('$R/R_{\odot}$')
plt.ylabel('$M/M_{\odot}$')
opt_plot()
plt.savefig('Mass_Radius.png', dpi = 400)
plt.show()


plt.plot(radius[:breaking_point]/R_Sun, F_C_[:breaking_point], color = 'blue')
plt.plot(radius[:breaking_point]/R_Sun, F_rad_[:breaking_point], color = 'red')
plt.title('Fraction of energy transported by \nconvection and radiation', fontsize = 17)
plt.axis([radius[breaking_point - 1]/R_Sun - 0.004, radius[0]/R_Sun + 0.004, -0.05, 1.05])
plt.legend(['$F_{conv.}/F$','$F_{rad.}/F$' ])
plt.xlabel('$R/R_{\odot}$')
plt.ylabel('Normalized Flux')
opt_plot()
plt.savefig('Normalized_Flux.png', dpi = 400)
plt.show()



# ---------------------------------------------------------------------------------------------------------------



# Printouts - output from the program:
'''
First sanity check (in order of example 5.1):
3.17477413853 0.4 31.6189478301 Mm 602985.321789 0.00118726165962 0.400001409593 65.4432165172 m/s 0.874006341195 0.125993658805
0.4 < 0.400000000003 < 0.400001409593 < 3.17477413853
Number of datapoints used: 337
Final radius: 4.93097592322 % of initial radius.
Final mass: 0.0105530142232 % of initial mass.
Final luminosity: 4.78654626411 % of initial luminosity.
Radius of the core: 29.747970883 % of initial radius.
Width of the outer convection layer: 19.3889555346 % of initial radius.
Width of the outer radiation layer: 49.8865635525 % of initial radius.
Width of the inner radiation layer: 20.3588634326 % of initial radius.
Width of the inner convection layer: 4.15961839927 % of initial radius.
'''